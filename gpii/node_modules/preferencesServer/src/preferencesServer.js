/*!
GPII Preferences Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/*global require, __dirname */

(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii");

    fluid.require("kettle", require);

    fluid.defaults("gpii.preferencesServer", {
        gradeNames: ["kettle.app", "autoInit"],
        handlers: {
            preferencesGet: {
                route: "/preferences/:userToken",
                type: "get"
            },
            preferencesPost: {
                route: "/preferences",
                type: "post"
            },
            preferencesPut: {
                route: "/preferences/:userToken",
                type: "put"
            },
            oldPreferencesGet: {
                route: "/oldPreferences/:userToken",
                type: "get"
            },
            oldPreferencesPost: {
                route: "/oldPreferences/:userToken?",
                type: "post"
            }
        },
        invokers: {
            getRawPreferences: {
                funcName: "gpii.preferencesServer.getRawPreferences",
                args: ["{gpii.preferencesServer}.rawPreferencesDataSource", "{arguments}.0"]
            },
            setRawPreferences: {
                funcName: "gpii.preferencesServer.setRawPreferences",
                args: ["{gpii.preferencesServer}.rawPreferencesDataSource", "{requestProxy}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        root: path.join(__dirname, ".."),
        components: {
            rawPreferencesDataSource: {
                type: "kettle.dataSource.URL",
                options: {
                    auth: "{gpii.preferencesServer}.options.auth",
                    url: "{gpii.preferencesServer}.options.urls.rawPreferences",
                    termMap: {
                        userToken: "%userToken"
                    },
                    writable: true
                }
            },
            ontologyHandler: {
                type: "gpii.ontologyHandler"
            }
        }
    });

    fluid.defaults("gpii.preferencesServer.dev", {
        gradeNames: ["autoInit", "kettle.urlExpander.distributeDevVariables"],
        components: {
            userSource: {
                type: "kettle.dataSource.URL",
                options: {
                    writeMethod: "POST"
                }
            }
        }
    });

    gpii.preferencesServer.getRawPreferences = function (rawPreferencesDataSource, userToken) {
        fluid.log("gpii.preferencesServer.getRawPreferences: entering");
        fluid.log("gpii.preferencesServer.getRawPreferences rawPreferencesDatasource: " + JSON.stringify(rawPreferencesDataSource), null, 2);
        fluid.log("gpii.preferencesServer.getRawPreferences userToken: " + userToken);
        if (userToken === undefined) {
            fluid.log("user token is undefined");
            fluid.fail("User token for getting preferences is undefined - aborting");
            return;
        }

        fluid.log("calling rawPreferencesDataSource.get(userToken)");
        var promiseTogo = fluid.promise();
        var promise = rawPreferencesDataSource.get({userToken: userToken});
        promise.then(function (data) {
            fluid.log("rawPreferencesDatasource promise is resolved with data: " + JSON.stringify(data, null, 2));
            // should be removed once KETTLE-33 is resolved
            if (data.isError !== undefined) {
                promiseTogo.reject(data);
                return;
            }
            promiseTogo.resolve(data.preferences || data);
        }, promiseTogo.reject);
        return promiseTogo;
    };

    gpii.preferencesServer.setRawPreferences = function (rawPreferencesDataSource, requestProxy, successEvent, body, userToken) {
        fluid.log("gpii.preferencesServer.setRawPreferences: entering");
        fluid.log("gpii.preferencesServer.setRawPreferences rawPreferencesDatasource: " + JSON.stringify(rawPreferencesDataSource, null, 2));
        fluid.log("gpii.preferencesServer.setRawPreferences body: " + JSON.stringify(body, null, 2));
        fluid.log("gpii.preferencesServer.setRawPreferences userToken: " + userToken);

        // if we were passed a user token, that means we want to do an update, else we're creating a new NP set
        var writeMethod = (userToken) ? "PUT" : "POST";
        fluid.log("writeMethod: " + writeMethod);


        var setOptions = {
            writeMethod: writeMethod
        };


        fluid.log("gpii.preferencesServer.setRawPreferences calling rawPreferencesDatasource.set");
        var promise = rawPreferencesDataSource.set({userToken: userToken || ""}, body,
            {writeMethod: writeMethod,
             auth_nouse: rawPreferencesDataSource.options.auth
             });

        fluid.log("gpii.preferencesServer.setRawPreferences registering callbacks to promise");
        promise.then(function(value){

            // the onSuccessEvent expects an object like
            // {
            //   userToken: "value",
            //   preferences; { ... }
            // }

            fluid.log("setRawPreferences has resolved with value: " + JSON.stringify(value));

            if (value.error) {
                requestProxy.events.onError.fire();
            }

            if (!value.userToken) {
                fluid.log("Response has no userToken, adding value.id");
                value.userToken = value.id;
            }
            if (!value.preferences) {
                fluid.log("Response has no preferences object, adding body");
                value.preferences = body;
            }


            fluid.log("triggering successEvent firing");
            successEvent.fire(value)
        }, requestProxy.events.onError.fire
        );
    };

    // TODO - should be removed or factored - just copied from gpii.request.flowmanager.logAndNotify
    gpii.preferencesServer.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    /*
     * Simple function to get the 'view' parameter from the request object. In case none is given,
     * defaults to the "flat" ontology.
     *
     * @request (Object) a request object
     *
     * @return (String) the value of the 'view' parameter of the request object, or "flat" if
     *     none is given
     */
    gpii.preferencesServer.getRequestView = function (request) {
        fluid.log("gpii.preferencesServer.getRequestView: entering");
        var returnvalue = (request.req.query && request.req.query.view) ? request.req.query.view : "flat";
        fluid.log("gpii.preferencesServer.getRequestView return value will be " + returnvalue);
        return returnvalue;
    };
})();
